## 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요 원칙
- 객체의 상태가 아닌, 객체의 행동에 초점을 맞추는 것.
- 책임은 객체의 상태에서 행동으로, 더 나아가 객체와 객체 사이의 상호작용으로 설계 중심을 이동시킨 후, 결합도가 낮고 응집도가 높으며 구현을 효과적으로 캡슐화하는 객체들을 창조할 수 있는 기반을 제공함


## 설계 트레이드오프
### 캡슐화 : 객체지향에서 가장 중요한 원리
- 외부에서 알 필요가 없는 부분을 감춰, 대상을 단순화시키는 추상화의 한 종류
  - 구현부 : 나중에 변경될 가능성이 높은 어떤 것
      - 구현부를 외부로부터 감추기 위해, 상태와 행동을 하나의 객체 안에 모아야 함
  - 인터페이스 : 상대적으로 안정적인 부분
        - 외부에는 되도록 인터페이스만 공개해야 함
- 불안정한 구현부를 인터페이스 뒤로 캡슐화 한다.
  - 변경의 여파 통제
  - 변경 가능성이 높은 것은 객체 내부로 숨긴다. -> 변경 될 수 있는 어떤것이라도 캡슐화를 하라.

    
### 응집도
- 모듈에 포함된 내부 요소들이 연관돼 있는 정도
- 모듈 내 요소들이 하나의 목적을 위해 긴밀하게 협력함 -> 높은 응집도
  - 다른 목적을 추구 -> 낮은 응집도
- 객체지향 관점
  - 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는가?
- 변경 관점
  - 변경이 발생할 때, 변경이 발생한 모듈 내부에서 발생하는 변경의 정도로 측정 가능.
  - 하나의 변경을 수용하기 위해, 변경이 일어난 요소를 포함한 모듈 전체가 함께 변경됨 -> 높은 응집도
    - 모듈의 일부만 변경됨 -> 낮은 응집도
  - 하나의 변경에 대해 하나의 모듈만 변경됨 -> 높은 응집도
    - 다수의 모듈이 함께 변경됨 -> 낮은 응집도
  - 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존함 -> 낮은 응집도
    - 코드를 수정하는 이유가 무엇인지 살펴보자.
- 응집도가 높을수록
  - 변경의 대상과 범위가 명확해진다. (오직 하나의 모듈만 수정하면 된다.)


### 결합도
- 의존성의 정도를 나타냄
- 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
- 어떤 모듈이 다른 모듈의 자세한 부분까지 안다 -> 높은 결합도
  - 꼭 필요한 지식만 안다 -> 낮은 결합도
- 객체지향 관점
  - 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는가?
- 변경 관점
  - 한 모듈이 변경되기 위해, 다른 모듈의 변경을 요구하는 정도로 측정 가능.
  - 하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는가?
  - 결합도가 높을수록, 변경해야 하는 모듈의 수가 증가한다.
  - 즉, 결합도가 높으면 변경이 어려워진다.
  - 영향받는 모듈 수 외에도, 변경의 원인으로 결합도를 설명할 수 있음
    - 내부 구현을 변경했을 때 다른 모듈에 영향을 미침 -> 결합도가 높음
      - 인터페이스를 수정했을 때만 다른 모듈에 영향을 미침 -> 결합도가 낮음 
- 따라서, 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.
- 결합도가 높아도 상관 없는 경우 (안정적인 모듈, 라이브러리 등)
  - 변경될 확률이 매우 적은 안정적인 모듈에 의존할 때
  - ex : `String`, `ArrayList`


### 좋은 설계
- 높은 응집도, 낮은 결함도를 가진 모듈로 구성된 설계
  - 설계를 변경하기 쉽게 만든다.
- 변경할 때, 너무 많은것을 함께 변경해야 할 경우, 응집도가 낮고 결합도가 높은 것이니 확인해보자.


### 캡슐화의 정도는 응집도와 결합도에 영향을 미친다!
- 캡슐화를 지키면 모듈 안의 응집도는 높아지고, 모듈 간 결합도는 낮아진다.
- 캡슐화를 위반하면 모듈 안의 응집도는 낮아지고, 모듈 간 결합도는 높아진다.


### 추측에 의한 설계 전략
- getter와 setter에 과도하게 의존하는 설계 방식
- 객체가 사용될 협력을 고려하지 않고, 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행함.


### 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 두지 말자!!
- 변경과 아무 상관 없는 코드들이 영향을 받게 된다.
- 어떤 코드를 수정한 후, 아무 상관도 없던 코드에 문제가 생긴다? 모듈의 응집도가 낮은것이다.


### 단일 책임 원칙(SRP)
- 모듈의 응집도가 변경과 연관이 있다는 사실을 강조하기 위해 제시된 원칙 (로버트 마틴)
- 클래스는 단 한가지의 변경 이유만 가져야 한다는 원칙이다.
- "책임"은 "변경의 의유"라는 의미이다. (역할, 책임, 협력의 책임과는 다르다.)


### 스스로 자신의 데이터를 책임지는 객체
- 객체는 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.
- 객체를 설계할 때 다음과 같은 두 개의 질문을 해야한다.
  - 이 객체가 어떤 데이터를 포함해야 하는가?
  - 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?


### 캡슐화 위반
```java
isDiscountable(DayOfWeek dayOfWeek, LocalTime time) {...}
```
- 메서드의 파라미터로도 추상화가 위반될 수 있다. 
  - 위 메서드의 시그니처를 보면, 파라미터에 `DayOfWeek`과 `LocalTime`을 받고 있는 것을 확인할 수 있다.
  - 따라서, 해당 메서드는 객체 내부에 `DayOfWeek`타입의 요일과 `LocalTime` 타입의 시간 정보가 인스턴스 변수로 포함돼있다는 사실을 인터페이스를 통해 위부에 노출하고 있는 것이다.


```text
calculateAmountDiscountedFee, calculatePercentDiscountedFee, calculateNoneDiscountedFee 
```
- 메서드 이름도 캡슐화를 위반하는 요인이 될 수 있다.
- 위 세 개의 메서드는 할인 정책에는 "금액 할인 정책, 비율 할인 정책, 미적용" 세 가지가 존재한다는 사실을 만천하에 드러내고 있다.

> 캡슐화란 변할 수 있는 어떤 것이라도 감추는 것이다. 그것이 속성의 타입이건, 할인 정책의 종류건 상관 없이 
> 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것이다. 
> 설계에서 변하는 것이 무엇인지 고려하고, 변하는 개념을 캡슐화 하자.



> 올바른 객체지향 설계의 무게 중심
> - 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.
> - 객체가 내부에 어떤 상태를 가지고, 그 상태를 어떻게 관리하는가는 부가적인 문제다.
> - 중요한 것은 객체가 다른 객체와 협력하는 방법이다.