# 상속과 코드 재사용 
## DRY(Don't Repeat Yourself) 원칙
> 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다. 
> - 한 번, 단 한 번 원칙 
> - 단일 지점 제어 원칙 
- 중복은 변경을 방해한다. 
- 중복의 기준은 변경이다.
  - 요구사항이 변경됐을 때, 두 코드를 함께 수정해야 한다면 이 코드는 중복이다.
- 모양이 유사한 것은 중복의 징후일 뿐이다. 중복 여부를 결정하는 기준은 **코드가 변경에 반응하는 방식**이다.


## 상속을 사용해 코드를 재사용하기 위해서는... 
- 부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다
- 이것은 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 함을 의미한다.
- 따라서, 상속은 결합도를 높인다. 
- 또한, 상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다.


## 상속을 위한 경고 
- 자식 클래스의 메서드 안에서 `super`참조를 이용해 부모 클래스의 메서드를 직접 호출하게 되면 두 클래스는 강하게 결합된다.
  - `super` 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라 
- 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다. 
- 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다. 


## 취약한 기반 클래스 문제
- 상속 관게로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상 
- 상속으로 인한 강한 결합도로 인해, 자식 클래스는 부모 클래스의 불필요한 세부사항에 엮이게 된다. 
- 상속 관계가 추가될수록 전체 시스템의 결합도는 높아진다. 
- 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에, 
  - 캡슐화를 약화시키고 결합도를 높인다.
- 상속은 코드의 재사용을 위해, 캡슐화의 장점을 희석시키고 구현에 대한 결합도를 높인다.
  - 이는 객체지향이 가진 강력함을 반감시킨다. 
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 경우, 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다. 


## 불필요한 인터페이스 상속 문제 
### 대표적인 예시, Stack!
- Stack은 Vector를 상속한다.
- Stack : LIFO 자료구조 
  - push, pop 오퍼레이션 제공 
- Vector : 임의의 위치에서 요소를 추출하고 삽입할 수 있는 리스트 자료 구조의 구현체(List 초기 버전)
  - get, add, remove 오퍼레이션 제공

Stack은 Vector를 상속받기 때문에, Vector의 퍼블릭 인터페이스가 합쳐진다. 따라서, Stack의 규칙을 쉽게 위반할 수 있게 된다. 


## 코드 중복을 제거하기 위한 원칙 
- 두 메서드가 유사하게 보인다면, 차이점을 메서드로 추출하라.
  - 메서드 추출을 통해, 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
- 부모 클래스의 코드를 하위로 내리지 말고, 자식 클래스의 코드를 상위로 올려라.
  - 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것 보다, 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.

