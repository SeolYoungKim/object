# 의존성 관리
- 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 -> 두 객체 사이에 의존성 존재
- 실행 시점과 구현 시점에 서로 다른 의미를 가짐 
  - 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 함 
  - 구현 시점 : 의존 대상 객체가 변경될 경우, 의존하는 객체도 함께 변경 됨 

## 의존성
- 의존성은 방향성을 가지며 항상 단방향이다 
- 런타임 의존성 : 객체 사이의 의존성
- 컴파일 타임 의존성 : 클래스 사이의 의존성 

> 어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는, 협력할 인스턴스의 구체적인 클래스를 알면 안된다.
> - 실제로 협력할 객체가 어떤 것인지는 런타임에 해결하라 (다형성 이용)
> - 컴파일 타임의 구조와 런타임 구조 사이의 거리가 멀면 멸수록 설계가 유연해지고 재사용 가능해진다.


## 컨텍스트 독립성
- 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이루어져 있다면, 다른 문맥에서 재사용하기가 훨씬 더 수월해진다.
- 의존성 해결 : 컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것 
  - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
  - 객체 생성 후 setter를 통해 의존성 해결
  - 메서드 실행 시 인자를 이용해 의존성 해결 


## 의존성과 결합도
- 의존성 : 두 요소 사이의 관계 유무를 설명
- 결합도 : 두 요소 사이에 존재하는 의존성의 정도를 상대적으로 표현 (결합도가 강하다/느슨하다)
- 한 요소가 다른 요소에 대해 더 많은 정보를 알고 있을수록 결합이 강해짐 -> 재사용할 수 있는 컨텍스트가 제한됨
- 결합도 : 구체 클래스 의존성 > 추상 클래스 의존성 > 인터페이스 의존성


## new는 해롭다
- 잘못 사용하면 결합도가 극단적으로 높아진다
  - `new`연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다 -> 추상화가 아닌 구체클래스에 의존하게 된다
  - `new`연산자는 생성하려는 구체 클래스 뿐만 아니라, 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. -> `new`를 사용하면 지식의 양이 늘기 때문에 결합도가 높아진다. 

- 가끔은 생성해도 무방하다
  - 협력하는 기본 객체를 설정하고 싶을 경우 


## 표준 클래스에 대한 의존은 괜찮다!
- JDK 표준 












