1장은 가볍게 객체지향 설계가 왜 필요한지 훑어보는 장이었던 것 같다.
따라서, 예제 코드를 작성하기 보다는 중요한 점들을 요약해보고자 한다.

### 예상을 빗나가는 코드
- 코드가 상식과 너무 다르게 동작하면, 코드를 읽는 사람과 제대로된 소통을 할 수 없다.
- 코드를 이해하기 위해 여러가지 세부적인 내용들을 한꺼번에 기억하고 있어야 하는 점이, 더욱 더 코드를 이해하기 어렵게 만든다.


### 변경에 취약한 코드
- 객체 사이의 의존성이 많아질 수록, 변경에 취약한 코드가 된다.
- 그렇다고 객체 사이의 의존성을 완전히 없는 것이 정답은 아니다. 
  - 객체 지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이기 때문!
- 그러므로, 애플리케이션의 기능을 구현하는 데 필요한 **최소한의 의존성만 유지**하고 **불필요한 의존성을 제거** 하자.
- 객체 간 의존성이 과한 경우를 가리켜 **결합도가 높다**고 한다.
- 객체 간 의존성이 합리적인 수준일 경우 **결합도가 낮다**고 한다.
- 결합도는 높으면 높을 수록, 함께 변경될 확률 또한 높아지기 때문에 변경하기가 어려워진다.
- 설계의 목표는 "객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것"이어야 한다.


## 설계 개선
### 자율성을 높이는 방법
- 객체를 자율적인 존재로 만들자.
- 자율적인 객체는, 객체 내부의 세부적인 사항을 감춰 "캡슐화(encapsulation)"을 달성하기 쉬워진다.
- 캡슐화의 목적은 "변경하기 쉬운 객체를 만드는 것"이다.
- 캡슐화를 통해 객체 내부로의 접근을 막으면, 객체 간 결합도를 낮출 수 있기 때문에 설계를 더 쉽게 변경할 수 있게 된다.
- 객체가 서로의 "인터페이스"에 의존하도록 만들자.
- 인터페이스와 구현을 나누어 인터페이스만 노출시키자.
- 객체는 자기 자신의 문제를 스스로 책임지고 해결해야 한다.


### 캡슐화와 응집도
- 객체 내부의 상태를 캡슐화 하고, 객체 간 오직 메세지를 통해서만 상호작용하도록 만들자.
- 객체는 다른 객체의 내부에 대해서는 알 필요가 없다. 단지 메세지를 이해할 수 있는가에 대한 여부만 알고 있을 뿐이다.
- 밀접하게 연관된 작업만을 수행하고, 연관성 없는 작업은 다른 객체에게 위임하는 객체를 **응집도가 높은 객체**라고 한다.
- 객체의 응집도를 높이기 위해서는 "객체 스스로 자신의 데이터를 책임"져야한다. 즉, 자신의 데이터를 스스로 처리하는 자율적인 존재여야 하는 것이다.


### 절차지향과 객체지향
- 절차 지향 프로그래밍 : 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
  - 이는 데이터 변경으로 인한 영향을 지역적으로 고립시키기 매우 어렵다.
  - 변경하기 어려운 코드를 양산하게 된다.
- 변경하기 쉬운 설계란, "한번에 하나의 클래스만 변경 할 수 있는 설계"이다.
- 객체 지향 프로그래밍 : 자신의 데이터를 객체 스스로 처리하도록, 즉 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 하는 프로그래밍 방식
  - 이는 변경으로 인한 여파가 여러 클래스로 전파되는 것을 효율적으로 억제할 수 있다.


### 책임의 이동
- 책임이란, 객체지향 세계에서 "기능을 가리키는 용어"이다.
- 책임은 한 곳에 집중되어 있어서는 안된다. 이는 적절히 분산되어야 한다.
  - 즉, 하나의 기능을 완성하는 데 필요한 책임은 여러 객체에 걸쳐 분산돼있어야 한다.
  - 한 객체에게 몰려있던 책임이 개별 객체로 이동하는 것을 "책임의 이동"이라고 한다.


> 좋은 설게를 할 때 고려해야 할 것
> - 불필요한 의존성을 제거하여 객체 간 결합도를 낮춘다.
> - 다른 객체가 몰라도 되는 세부 사항은 내부로 감춰 캡슐화 한다.
> - 객체의 자율성을 높이고, 응집도를 높인 객체들의 공동체를 만들자.
> - 최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계다.
> - 훌륭한 설계는 적절한 트레이드 오프의 결과물이다.
> - 객체를 의인화 하여 능동적이고 자율적인 존재로 만들어라.


### 설계의 정의
> *설계란, 코드를 배치하는 것이다*


### 변경 가능한 코드는 이해하기 쉬운 코드다.
