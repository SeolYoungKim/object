# 서브클래싱과 서브타이핑 
## 상속은 두 가지 용도로 사용된다
### 타입 계층 구현
- 부모 클래스는 일반적인 개념을 구현
  - 자식 클래스의 일반화
- 자식 클래스는 특수한 개념을 구현
  - 부모 클래스의 특수화 

### 코드 재사용 
- 점진적으로 애플리케이션의 기능을 확장할 수 있음 
- 재사용을 위해 상속을 사용할 경우, 부모 클래스와 자식 클래스가 강하게 결합되어 변경하기 어려운 코드를 얻게 될 확률이 높음

## 상속은 타입 계층 구현을 위해 사용하라 
- 다형적으로 동작하는 객체들의 관계에 기반해 확장 가능하고 유연한 설계를 얻을 수 있게 된다.


## 타입
### 개념 관점의 타입 
- 우리가 인지하는 세상의 사물의 종류를 의미 
  - 즉, 우리가 인식하는 객체들에 적용하는 개념이나 아이디어를 가리켜 타입이라고 부름 
  - 사물을 분류하기 위한 틀이다. 
- 어떤 대상이 타입으로 분류될 때, 해당 대상을 타입의 인스턴스라고 부름 
  - 프로그래밍 언어 : 타입
    - 자바, 루비, 자바스크립트 : 인스턴스(객체)
- 타입의 구성요소
  - 심볼
    - 타입에 이름을 붙인 것 
    - "프로그래밍 언어"가 타입의 심볼에 해당
  - 내연
    - 타입의 정의
    - 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동 
      - 프로그래밍 언어의 정의인 "컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합"이 내연에 속함
  - 외연
    - 타입에 속하는 객체들의 집합
    - 자바, 루비, 자바스크립트...


### 프로그래밍 언어 관점의 타입 
- 연속적인 비트에 의미와 제약을 부여하기 위해 사용 
- 하드웨어는 데이터를 0과 1로 구성된 일련의 비트 조합으로 취급 -> 비트 자체에는 타입이라는 개념이 존재하지 않음 
  - 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 데이터를 사용하는 애플리케이션에 의해 결정 됨 
- 프로그래밍 언어에서의 타입은 두 가지 목적을 위해 사용 됨
  - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의
    - `+` 등의 연산자를 정의
  - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공 
    - 문자열 + 문자열 = 문자열 결합
    - 정수형 + 정수형 = 덧셈 

> 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의하여, 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용된다.


### 객체지향 패러다임 관점의 타입
- 개념 관점 : 공통의 특징을 공유하는 대상들의 분류
- 프로그래밍 언어 관점 : 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합 
  - 객체지향 프로그래밍에서는 "객체가 수신할 수 있는 메시지"를 의미 

따라서, 객체의 타입이란 **객체가 수신할 수 있는 메시지의 종류를 정의하는 것**이다.
- 객체지향 프로그래밍에서의 타입 정의 == 객체의 퍼블릭 인터페이스를 정의 
- 동일한 퍼블릭 인터페이스를 가지는 객체 == 동일한 타입


> 객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰라
> - 객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 외부에 제공하는 행동이다 


## 타입 계층 
- 슈퍼타입 : 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입
- 서브타입 : 타입 계층을 구성하는 두 타입 간의 관계에서 더 특수한 타입


- 일반화 : 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과 
- 특수화 : 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과


## 서브 클래싱과 서브 타이핑 
### 언제 상속을 사용해야 하는가?
- `is-a`관계인가?
  - [자식클래스]는 [부모클래스]다 라고 말할 수 있는가
- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
  - 클라이언트는 부모 클래스와 자식 클래스의 차이를 몰라야한다. (행동 호환성)
  - 클라이언트 관점에서 두 클래스에 대해 기대하는 행동이 다르다면, `is-a`관계라 할지라도 상속을 사용해서는 안됨 


### is-a
- 어휘적인 정의가 아닌 기대되는 행동에 따라 타입 계층을 구성해야 한다.
  - ex: 펭귄 - 새 
- 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다. 


### 행동 호환성 
- 두 타입 간에 행동이 호환될 경우에만 타입 계층으로 묶어라 
- 행동 호환 여부 판단 기준은 **클라이언트 관점**이다 


### 인터페이스 분리 원칙 
- 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의한 영향을 제어하는 설계 원칙  
- 클라이언트는 자신이 실제로 호출하는 메서드에만 의존해야 함 
  - 호출하지 않는 메서드에 대한 의존성은 끊자 
  - 클라이언트가 서로에 대해 독립적이 되도록 하자 

> 자연어에 현혹되지 말고, 요구사항 속에서 클라이언트가 기대하는 행동에 집중하라
> - 불필요한 기능은 구현해두지 않아도 된다.
> - 클래스 이름 사이에 어떠한 연관성이 있다는 사실은 아무 의미가 없다. 
>   - 두 클래스 간 행동이 호환되지 않는다면 올바른 타입 계층이 아니다. -> 상속 사용 X


### 서브 클래싱
- 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우 
- 부모-자식 간 행동이 호환되지 않음 
- 자식 클래스의 인스턴스가 부모 인스턴스 대체 불가
- 구현 상속 or 클래스 상속이라고 부르기도 함 


### 서브 타이핑 
- 타입 계층을 구성하기 위해 상속을 사용하는 경우 
- 부모-자식 간 행동이 호환됨 
- 자식 클래스의 인스턴스가 부모 인스턴스 대체 가능 
  - 부모 클래스 : 슈퍼 타입
  - 자식 클래스 : 서브 타입
- 인터페이스 상속이라고 부르기도 함 
- 자식 클래스가 부모 클래스를 대신할 수 있기 위해서는 자식 클래스가 부모 클래스가 사용되는 모든 문맥에서 자식 클래스와 동일하게 행동할 수 있어야 함 
- 행동 호환성 : 부모 클래스에 대한 자식 클래스의 대체 가능성을 포함함
  - 부모 클래스를 새로운 자식 클래스로 대체하더라도 시스템이 문제없이 동작할 것이라는 것을 보장해야 함 


## 리스코프 치환 원칙 
- 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다 
- 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.
- 위반 사례
  - `Stack` - `Vector`
  - 직사각형 - 정사각형

### 직사각형 - 정사각형 예시
- 직사각형은 너비와 높이가 다를 수 있다고 가정
- 정사각형은 너비와 높이가 항상 동일하다고 가정 
- 예시의 `resize`메서드는 `Rectangle`의 가정에 기반한다. -> 너비와 높이를 독립적으로 변경할 수 있다고 가정 
  - 하지만 `Square`를 전달하면 가정이 무너진다. 
  - 이 경우 `Rectangle`대신 `Square`를 사용할 수 없다 -> 구현을 재사용 할 뿐이다. 
  - 리스코프 치환 원칙을 위반하기 때문에 서브타이핑 관계가 아닌 서브클래싱 관계다.


> 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다 
> - 어떤 모델의 유효성은 클라이언트 관점에서만 검증 가능하다는 것 
> - 상속 관계는 클라이언트 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을 때만 올바르다 
> - 대체 가능성을 결정하는 것은 클라이언트다
> - 이름이 아니라 행동이 먼저다 


## 계약에 의한 설계와 서브타이핑 
### 계약에 의한 설계
- 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것
- 구성 요소 
  - 사전조건 : 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 조건
  - 사후조건 : 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 조건 
  - 클래스 불변식 : 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 것  

서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 "계약"을 준수해야 한다.
- 협력하는 클라이언트와 슈퍼타입 인스턴스 사이에는 어떤 계약이 맺어져있다
  - 클라이언트와 슈퍼타입은 이 계약을 준수할 때만 정상적으로 협력할 수 있다
- 리스코프 치환 원칙은 서브타입이 그것의 슈퍼타입을 대체할 수 있어야 한다
  - 클라이언트가 차이점을 인식하지 못한 채 슈퍼타입의 인터페이스를 이용해 서브타입과 협력할 수 있어야 한다.
  - 클라이언트 입장에서 서브타입은 슈퍼타입의 **한 종류** 여야 한다.
- 모든 서브클래스가 서브타입인 것은 아니다.
  - 코드 재사용을 위해 상속을 사용한 경우 -> 서브타입 아님
  - 클라이언트의 관점에서 자식이 부모를 대체할 수 없는 경우 -> 서브타입 아님
- 서브타입이 슈퍼타입처럼 보일 수 있는 유일한 방법은 클라이언트가 슈퍼타입과 맺은 계약을 서브타입이 준수하는 것 뿐 

### 사전조건과 사후조건
```java
public abstract class DiscountPolicyWithAssert {
    public Money calculateDiscountAmount(Screening screening) {
        checkPreCondition(screening);

        Money amount = Money.ZERO;
        // 메서드 구현 

        amount = screening.getMovieFee();
        checkPostCondition(amount);
        return amount;
    }

    private void checkPreCondition(Screening screening) {
        assert screening != null && screening.getStartTime().isAfter(LocalDateTime.now());
    }

    private void checkPostCondition(Money amount) {
        assert amount != null && amount.isGreaterThanOrEqual(Money.ZERO);
    }
    
}
```
- calculateDiscountAmount 메서드가 정의한 사전조건을 만족시키는 것은 Movie의 책임
  - 사전조건을 위반하는 screening을 전달하면 안됨 


### 서브타입과 계약 
- 계약 관점에서 상속이 초래하는 가장 큰 문제는 **자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 수 있다는 것**이다
- 부모 클래스의 메서드를 오버라이딩하여 재정의한 경우, 부모 클래스를 사용하는 클라이언트는 부모 클래스의 메서드와의 계약 사항밖에 모른다. 떄문에, 이것만 지키려고 할텐데, 만약 해당 메서드를 재정의한 자식 클래스가 구현체로 넣어진다면...
  - 예시의 `BrokenDiscountPolicy`는 `DiscountPolicy`를 대체할 수 없기 떄문에 서브타입이 아니다.
  - 즉, 서브타입에 더 강력한 사전조건을 정의할 수 없다!
- 반대로 사전 조건을 제거해서 약화시킨다면 기존 협력에 어떠한 영향도 미치지 않는다
  - 아무런 문제가 발생하지 않는다
  - 즉, 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다 
- 만약 사후조건을 강화한다면 ? 
  - 클라이언트는 `DiscountPolicy`의 사후조건만 알고있다. 즉, 0원보다 큰 금액을 반환받기만 하면 협력은 정상수행된다.
  - 때문에, `BrokenDiscountPolicy`가 1000원 이상의 금액을 반환하는 것은 `Movie`와 `DiscountPolicy`간의 계약사항을 위반하지 않는다.
  - 즉, 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다
- 반대로 사후조건을 제거해서 약화시킨다면?
  - 변경된 코드에서는 요금 계산 결과가 마이너스라도 그대로 반환하게 된다.
  - 하지만 `Movie`는 `DiscountPolicy`가 반환하는 금액이 0보다는 크다고 믿고 사용할 것이다.
  - 하지만, 예매 금액이 마이너스로 설정되는, 원치 않는 결과로 이어지고 만다.
  - 즉, 서브 타입에 더 약한 사후조건을 정의할 수 없다.






