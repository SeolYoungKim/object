# 유연한 설계 
## 개방 폐쇄 원칙
- Open-Closed Principle, OCP
- 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 열려있어야 하고, 수정에 대해서는 닫혀있어야 한다.
  - 확장에 대해 열려있다 : 요구사항이 변경될 때, 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다
  - 수정에 대해 닫혀있다 : 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다 
- 컴파일타임 의존성과 런타임 의존성에 관한 이야기다.
- 추상화에 의존하라 
  - 공통점을 반영한 부분은 수정에 대해 닫혀있다. (수정 할 필요가 없다) : 변하지 않는 부분 고정 
  - 추상화를 통해 생략된 부분(추상 메서드)은 확장의 여지다. -> 구체화 하여 확장 : 변하는 부분 생략


## 생성과 사용은 분리하라 
- 객체와 관련된 생성과 사용의 두 가지 책임은 서로 분리해야 한다 
- 소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 연결하는) 시작 단계와 (이후에 이어지는) 실행 단계를 분리해야 한다 
- 객체 생성 책임을 클라이언트로 옮기자


## 책임을 할당할 때
- 책임 할당의 기본 : 책임을 수행하는 데 필요한 정보를 가장 많이 알고있는 `Information expert`에게 책임을 할당할 것 
- 어떤 책임을 할당하고 싶다면, 제일 먼저 도메인 모델 안의 개념 중에서 적절한 후보가 존재하는지 확인해라
- `Factory`는 순수하게 기술적인 결정이며, 도메인 모델에 속하지는 않는다. 
  - 도메인 개념에게 할당돼 있던 객체 생성 책임을 도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동시킨 것 
  - 전체적으로 결합도를 낮추고 재사용성을 높일 수 있게 되었음 
- 표현적 분해 : 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것 
  - 도메인 모델에 담겨있는 개념과 관계를 따름 
  - 도메인과 소프트웨어 사이의 표현적 차이를 최소화 하는 것을 목적으로 함 
  - 객체지향 설계를 위한 가장 기본적인 접근법
- 하지만, 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우가 발생할 수 있다 
  - 도메인 모델은 설계를 위한 출발점일 뿐이다. (중요하긴 함)
  - 실제로 동작하는 애플리케이션은 DB 접근을 위한 객체 등, 도메인 개념을 초월하는 기계적인 개념들을 필요로 할 수 있다.

> 고로, 모든 책임을 도메인 객체에게 할당할 수는 없다. 
> - 이러한 경우, 도메인 개념을 표현한 객체가 아닌, 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결하자. 

## 순수한 가공물(Pure fabrication)
- 행동을 책임질 마땅한 도메인 개념이 존재하지 않을 때 사용 
- 특정한 행동을 표현하게 된다. (Factory)
- 행위적 분해에 의해 생성된다. 


## 애플리케이션 모델
- 도메인 개념을 표현하는 객체와, 순수하게 창조된 가공의 객체들이 모여 자신의 역할과 책임을 다하고 조화롭게 협력하는 애플리케이션을 설계 
- 도메인의 본질적인 개념을 표현하는 추상화를 이용해 애플리케이션을 구축 
  - 도메인 개념이 만족스럽지 못하다면, 주저말고 인공적인 객체를 창조할 것 


## Pure fabrication 패턴
- 객체지향 설계
  - 도메인 상의 개념을 소프트웨어 객체로 구현하고 책임을 할당함 
  - 도메인 객체에 책임을 할당할 경우, high cohesion, low coupling, 재사용성 등의 목적을 위반한다면? 
- 인위적으로, 또는 편의상 만든 클래스에 매우 응집된 책임을 할당해라 
  - 이들 클래스는 도메인 상에는 존재하지 않지만, 순수하게 전체 설계의 품질을 높이기 위해 설계자의 임의에 따라 추가한 상상 속의 가공물이다 
- Pure fabrication 패턴은 information expert 패턴에 따라 책임을 할당한 결과가 바람직하지 않을 경우, 대안으로 사용 됨 
  - 어떤 객체가 책임을 수행하는 데 필요한 많은 정보를 가졌지만 해당 책임을 할당할 경우, 응집도가 낮아지고 결합도가 높아진다면 가공의 객체를 추가해서 책임을 옮기는 것을 고민하라


## Service locator 패턴
- 의존성을 해결할 객체들을 보관하는 일종의 저장소 
- 외부에서 의존성을 전달하는 의존성 주입과 달리, 객체가 직접 의존성을 해결해줄 것을 service locator 에게 요청한다 
- 해당 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지(구체 클래스의 타입이 무엇인지), 어디에 있는지(클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해준다 
- 의존성을 감춘다는 큰 단점이 있다 
  - 때문에, 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아닌 실행 시점으로 미루게 된다 
  - 의존성을 숨기면 단위 테스트 작성도 어렵다 
  - 의존성이 감춰지면 내부를 다 찾아봐야 하기 떄문에, 캡슐화를 위반한다.
- 가급적이면 의존성을 객체의 인터페이스에 노출하라 
- 접근할 객체가 있다면, 전역 메커니즘 대신 필요한 객체를 인수로 넘겨줄 수는 없는지 고려하라 
  - 쉽고, 결합을 명확하게 보여줄 수 있다


## 의존성 역전 
- 상위 수준의 클래스가 하위 수준의 구체적인 클래스에 의존하면 안된다
- 추상화에 의존하라 !! 구체클래스는 의존성의 시작점 이어야 하지, 목적지여서는 안된다. 
> 의존성 역전 원칙
> - 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다 
> - 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다 


## 의존성 역전과 패키지
- 컴파일타임 의존성 : 코드의 컴파일이 성공하기 위해 함께 존재해야 하는 코드를 정의하는 것 
- 불필요한 클래스들을 같은 패키지에 두는 것 -> 재배포 시 함께 배포되어야 할 패키지들이 늘어남 -> 빌드 시간 상승 요인 
- 예시 : Movie와 DiscountPolicy
  - Movie의 재사용을 위해 필요한 것 -> DiscountPolicy 뿐.. 나머지느 필요 없다 
  - Movie와 DiscountPolicy를 같은 패키지로 모으고, AmountDiscountPolicy와 PercentDiscountPolicy를 별도의 패키지에 위치시킨다
  - 추상화 클래스는 그를 구현한 클래스들이 아닌, 그를 의존하고 "사용"하는 클라이언트가 속한 패키지에 포함시켜야 한다.
  - 함께 재사용될 필요가 없는 클래스들은 별도의 패키지에 모으자 
- 이를 `Separated interface`패턴이라고 부른다 
- 위 방안은 Movie를 특정한 컨텍스트로부터 완벽히 독립시킨다. 
- Movie를 다른 컨텍스트에서 재사용 하기 위해서는, 단지 Movie와 DiscountPolicy가 포함된 패키지만 재사용하면 된다 
- 의존성 역전 원칙에 따라, 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 또한 역전시켜야 한다.
  - 인터페이스의 소유권을 서버 모듈이 아닌, 클라이언트 모듈에 위치시키자


## 유연성에 대한 조언
### 유연한 설계는 유연성이 필요할 때만 옳다
- 유연한 설계(변경하기 쉽고 확장하기 쉬운)는 단순함과 명확함의 미덕을 버리게 될 가능성이 높다.
- 유연한 설계라는 말의 이면에는 "복잡한 설계"라는 의미가 숨어있다 
- 아직 일어나지 않은 변경은 변경이 아니다. 미래를 과하게 걱정하면 복잡한 설계를 낳게 될것..
  - 불필요한 유연성 -> 불필요한 복잡성 
- 유연함이 필요하다면 코드 구조와 실행 구조를 다르게 만들어라 (런타임 vs 컴파일타임)


### 협력과 책임이 중요하다 
- 협력에 참여하는 객체가 다른 객체에게 어떤 메세지를 전송하는가 ?
- Movie -> calculateDiscountAmount 메세지 전송 -> DiscountPolicy를 구현한 구현체들 모두가 해당 메세지를 이해할 수 있다. 
  - 요금 계산을 위한 협력에 참여하면서, 할인 요금을 계산하는 책임을 수행할 수 있다
  - 심지어 Movie의 입장에서 동일한 역할을 수행할 수 있다 

- 다양한 컨텍스트에서 협력을 재사용 할 필요가 없다면 ?
  - 설계를 유연하게 만들 당위성도 함께 사라진다. 
  - 객체들이 메시지 전송자의 관점에서 동일한 책임을 수행하는지 여부를 판단할 수 없다면 공통의 추상화를 도출할 수 없다 
  - 동일한 역할을 통해 객체들을 대체 가능하게 만들지 않았다면, 협력에 참여하는 객체들을 교체할 필요가 없다. 

> 초보자들이 자주 저지르는 실수
> - 객체의 역할과 책임이 자리를 잡기 전에, 너무 성급하게 객체 생성에 집중하는 것 
> - 이것은 객체 생성과 관련된 불필요한 세부 사항에 객체를 결합시킨다. 
> - 객체를 생성할 책임을 담당할 객체나, 객체 생성 메커니즘을 결정하는 시점은 책임 할당의 마지막 단계로 미뤄야 한다.
> - 중요한 비즈니스 로직을 처리하기 위해, 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것 보다 우선이다!!
> - 특히, 책임의 불균형이 심화되고 있는 상태에서 객체의 생성 책임을 부여하는 것은, 설계를 하부의 특정한 메커니즘에 종속적으로 만들 확률이 높다.
>   - 불필요한 싱글톤(singleton) 패턴은 객체 생성에 관해 너무 이른 시기에 고민하고 결정할 떄 도입되는 경향이 있다.
> - 핵심은, 객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는게 적절하다는 것이다. 