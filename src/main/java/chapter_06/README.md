# 클라이언트-서버 모델
- 클라이언트 : 메세지를 전송하는 객체
- 서버 : 메세지를 수신하는 객체
- 협력 : 단방향 상호작용 
- 퍼블릭 인터페이스 : 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
- 오퍼레이션 : 퍼블릭 인터페이스에 포함된 메시지 (수행 가능한 어떤 행동에 대한 추상화. 시그니처만 정의) 
  - 실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세 
  - 인터페이스의 각 요소 
- 메서드 : 메시지 수신 시, 실제로 실행되는 코드(시그니처 + 구현)
  - 오퍼레이션을 구현한 것 
- 다형성 : 동일한 오퍼레이션 호출, 서로 다른 메서드 수행


# 디미터 법칙
- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라 
  - 낯선 자에게 말하지 말라
  - 오직 인접한 이웃하고만 말하라 
  - 오직 하나의 dot(`.`)만 사용하라
- 클래스 C와 C에 구현된 모든 메서드 M에 대해
  - M이 메시지를 전송할 수 있는 모든 객체는 다음과 같다.
    - M의 인자로 전달된 클래스(C 자체 포함)
    - C의 인스턴스 변수의 클래스
  - 이 때, M에 의해 생성된 객체나 M이 호출하는 메서드에 의해 생성된 객체, 전역 변수로 선언된 객체는 모두 M의 인자로 간주한다.
- 즉, 아래 조건을 만족하는 인스턴스를 말한다.
  - `this`객체
  - 메서드의 매개변수
  - `this`의 속성 
  - `this`의 속성인 컬렉션의 요소
  - 메서드 내에서 생성된 지역 객체 
- 객체의 내부 구조를 묻지 말고, 수신자에게 무언가를 시켜라.
> 무비판적으로 디미터 법칙을 수용하면
> - 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수도 있다.


# 묻지 말고 시켜라 
- 객체의 상태를 묻지 말고, 원하는 것을 시켜라 
- 상태를 묻는 오퍼레이션 -> 행동을 요청하는 오퍼레이션으로 대체 


# 의도를 드러내는 인터페이스 (의도를 드러내는 선택자)
- "어떻게"가 아니라, "무엇"을 하는지 드러내라 
  - 어떻게 : 내부 구현을 설명
  - 무엇 : 객체가 협력 안에서 수행해야 하는 책임에 관해 설명 -> 동일한 목적, 동일한 책임 
    - -> interface를 통해 하나의 역할(타입)로 묶을 수 있음

> 하나의 구현을 가진 메시지의 이름을 일반화하도록 도와주는 방법
> - 매우 다른 두번째 구현을 상상
> - 해당 메서드에 동일한 이름을 붙인다고 상상
> - 그 순간에 가장 추상적인 이름을 붙일 수 있을 것 

- 협력과 관련된 의도를 드러내라!


# 원칙의 함정 
- 설계는 트레이드오프의 산물이다.
- 현재 상황에 부적합하다고 판단될 경우, **과감하게 원칙을 무시**하라

## 디미터 법칙은 하나의 도트(`.`)를 강제하는 규칙이 아니다
- java8의 스트림은 디미터 법칙을 위반하지 않는다. 
- 디미터 법칙은 결합도와 관련된 것이며, 결합도가 문제가 되는 것은 **객체의 내부 구조가 외부로 노출되는 경우**로 한정된다.
- 여러개의 도트를 사용한 코드가 **객체의 내부 구조를 노출 하고 있는지**를 확인할 것


## 결합도와 응집도의 충돌 
- 맹목적으로 위임 메서드를 추가할 경우 
  - 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 됨 
  - 객체는 상관 없는 책임들을 한꺼번에 떠안아 응집도가 낮아진다 
- 가끔은 묻는 것 밖에 답이 없을 때도 있다
  - 필요에 따라 물어야 할 수 밖에 없다!

> 디미터 법칙의 위반 여부는 묻는 대상이 **객체**인지, **자료구조**인지에 달려있다.
> - 객체는 내부 구조를 숨겨야 하기 때문에 디미터 법칙을 따르는 것이 좋다  
>
> 
> - 자료구조는 당연히 내부를 노출해야 하기 때문에 디미터 법칙을 적용할 필요가 없다  
> 
> 그러므로, 원칙을 맹신하지 마라. 소프트웨어에 법칙이란 없다. 설계는 트레이드오프의 산물이다.



## 명령-쿼리 분리 원칙 
- 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침
  - 루틴 : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈 
    - 루틴 = 프로시저 + 함수
    - 프로시저 : 정해진 절차에 따라 내부의 상태를 변경 (부수효과를 발생시킬 수 있지만, 값을 반환할 수 없음) -> `void`
    - 함수 : 어떤 절차에 따라 필요한 값을 계산해서 반환 (값을 반환할 수 있지만, 부수효과를 발생시킬 수 없음) -> `return`


- 명령과 쿼리 : 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름
  - 명령 : 객체의 상태를 수정 (프로시저)
  - 쿼리 : 객체와 관련된 정보를 반환 (함수)


> 오퍼레이션은 부수 효과를 발생시키는 명령(command)이거나, 부수 효과를 발생시키지 않는 쿼리(query)중 하나여야 한다.
> - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다
> - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다 
> 
> 즉, 질문이 답변을 수정해서는 안된다!

- 명령과 쿼리가 뒤섞이면 실행 결과를 예측하기가 어려워질 수 있다.
  - 겉으로는 쿼리처럼 보이지만, 내부적으로 부수 효과를 가지는 메서드는 이해하기가 어렵고, 잘못 사용하기 쉬우며, 버그를 양산하는 경향이 있다. 


## 명령-쿼리 분리와 참조 투명성 
- 부수 효과의 존재 유무  
- 참조 투명성 : 어떤 표현식 e 가 있을 떄, e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성 















